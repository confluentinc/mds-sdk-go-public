// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: api_rbac_role_definitions.go

package mock

import (
	context "context"
	net_http "net/http"
	sync "sync"

	github_com_confluentinc_mds_sdk_go_mdsv2alpha1 "github.com/confluentinc/mds-sdk-go/mdsv2alpha1"
)

// RBACRoleDefinitionsApi is a mock of RBACRoleDefinitionsApi interface
type RBACRoleDefinitionsApi struct {
	lockRoleDetail sync.Mutex
	RoleDetailFunc func(ctx context.Context, roleName string, localVarOptionals *github_com_confluentinc_mds_sdk_go_mdsv2alpha1.RoleDetailOpts) (github_com_confluentinc_mds_sdk_go_mdsv2alpha1.Role, *net_http.Response, error)

	lockRolenames sync.Mutex
	RolenamesFunc func(ctx context.Context, localVarOptionals *github_com_confluentinc_mds_sdk_go_mdsv2alpha1.RolenamesOpts) ([]string, *net_http.Response, error)

	lockRoles sync.Mutex
	RolesFunc func(ctx context.Context, localVarOptionals *github_com_confluentinc_mds_sdk_go_mdsv2alpha1.RolesOpts) ([]github_com_confluentinc_mds_sdk_go_mdsv2alpha1.Role, *net_http.Response, error)

	calls struct {
		RoleDetail []struct {
			Ctx               context.Context
			RoleName          string
			LocalVarOptionals *github_com_confluentinc_mds_sdk_go_mdsv2alpha1.RoleDetailOpts
		}
		Rolenames []struct {
			Ctx               context.Context
			LocalVarOptionals *github_com_confluentinc_mds_sdk_go_mdsv2alpha1.RolenamesOpts
		}
		Roles []struct {
			Ctx               context.Context
			LocalVarOptionals *github_com_confluentinc_mds_sdk_go_mdsv2alpha1.RolesOpts
		}
	}
}

// RoleDetail mocks base method by wrapping the associated func.
func (m *RBACRoleDefinitionsApi) RoleDetail(ctx context.Context, roleName string, localVarOptionals *github_com_confluentinc_mds_sdk_go_mdsv2alpha1.RoleDetailOpts) (github_com_confluentinc_mds_sdk_go_mdsv2alpha1.Role, *net_http.Response, error) {
	m.lockRoleDetail.Lock()
	defer m.lockRoleDetail.Unlock()

	if m.RoleDetailFunc == nil {
		panic("mocker: RBACRoleDefinitionsApi.RoleDetailFunc is nil but RBACRoleDefinitionsApi.RoleDetail was called.")
	}

	call := struct {
		Ctx               context.Context
		RoleName          string
		LocalVarOptionals *github_com_confluentinc_mds_sdk_go_mdsv2alpha1.RoleDetailOpts
	}{
		Ctx:               ctx,
		RoleName:          roleName,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.RoleDetail = append(m.calls.RoleDetail, call)

	return m.RoleDetailFunc(ctx, roleName, localVarOptionals)
}

// RoleDetailCalled returns true if RoleDetail was called at least once.
func (m *RBACRoleDefinitionsApi) RoleDetailCalled() bool {
	m.lockRoleDetail.Lock()
	defer m.lockRoleDetail.Unlock()

	return len(m.calls.RoleDetail) > 0
}

// RoleDetailCalls returns the calls made to RoleDetail.
func (m *RBACRoleDefinitionsApi) RoleDetailCalls() []struct {
	Ctx               context.Context
	RoleName          string
	LocalVarOptionals *github_com_confluentinc_mds_sdk_go_mdsv2alpha1.RoleDetailOpts
} {
	m.lockRoleDetail.Lock()
	defer m.lockRoleDetail.Unlock()

	return m.calls.RoleDetail
}

// Rolenames mocks base method by wrapping the associated func.
func (m *RBACRoleDefinitionsApi) Rolenames(ctx context.Context, localVarOptionals *github_com_confluentinc_mds_sdk_go_mdsv2alpha1.RolenamesOpts) ([]string, *net_http.Response, error) {
	m.lockRolenames.Lock()
	defer m.lockRolenames.Unlock()

	if m.RolenamesFunc == nil {
		panic("mocker: RBACRoleDefinitionsApi.RolenamesFunc is nil but RBACRoleDefinitionsApi.Rolenames was called.")
	}

	call := struct {
		Ctx               context.Context
		LocalVarOptionals *github_com_confluentinc_mds_sdk_go_mdsv2alpha1.RolenamesOpts
	}{
		Ctx:               ctx,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.Rolenames = append(m.calls.Rolenames, call)

	return m.RolenamesFunc(ctx, localVarOptionals)
}

// RolenamesCalled returns true if Rolenames was called at least once.
func (m *RBACRoleDefinitionsApi) RolenamesCalled() bool {
	m.lockRolenames.Lock()
	defer m.lockRolenames.Unlock()

	return len(m.calls.Rolenames) > 0
}

// RolenamesCalls returns the calls made to Rolenames.
func (m *RBACRoleDefinitionsApi) RolenamesCalls() []struct {
	Ctx               context.Context
	LocalVarOptionals *github_com_confluentinc_mds_sdk_go_mdsv2alpha1.RolenamesOpts
} {
	m.lockRolenames.Lock()
	defer m.lockRolenames.Unlock()

	return m.calls.Rolenames
}

// Roles mocks base method by wrapping the associated func.
func (m *RBACRoleDefinitionsApi) Roles(ctx context.Context, localVarOptionals *github_com_confluentinc_mds_sdk_go_mdsv2alpha1.RolesOpts) ([]github_com_confluentinc_mds_sdk_go_mdsv2alpha1.Role, *net_http.Response, error) {
	m.lockRoles.Lock()
	defer m.lockRoles.Unlock()

	if m.RolesFunc == nil {
		panic("mocker: RBACRoleDefinitionsApi.RolesFunc is nil but RBACRoleDefinitionsApi.Roles was called.")
	}

	call := struct {
		Ctx               context.Context
		LocalVarOptionals *github_com_confluentinc_mds_sdk_go_mdsv2alpha1.RolesOpts
	}{
		Ctx:               ctx,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.Roles = append(m.calls.Roles, call)

	return m.RolesFunc(ctx, localVarOptionals)
}

// RolesCalled returns true if Roles was called at least once.
func (m *RBACRoleDefinitionsApi) RolesCalled() bool {
	m.lockRoles.Lock()
	defer m.lockRoles.Unlock()

	return len(m.calls.Roles) > 0
}

// RolesCalls returns the calls made to Roles.
func (m *RBACRoleDefinitionsApi) RolesCalls() []struct {
	Ctx               context.Context
	LocalVarOptionals *github_com_confluentinc_mds_sdk_go_mdsv2alpha1.RolesOpts
} {
	m.lockRoles.Lock()
	defer m.lockRoles.Unlock()

	return m.calls.Roles
}

// Reset resets the calls made to the mocked methods.
func (m *RBACRoleDefinitionsApi) Reset() {
	m.lockRoleDetail.Lock()
	m.calls.RoleDetail = nil
	m.lockRoleDetail.Unlock()
	m.lockRolenames.Lock()
	m.calls.Rolenames = nil
	m.lockRolenames.Unlock()
	m.lockRoles.Lock()
	m.calls.Roles = nil
	m.lockRoles.Unlock()
}
